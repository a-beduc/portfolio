{ "header": {
    "name": "Alexandre Beduc.",
    "nav": {
      "aboutMe": "À propos de moi",
      "project": "Projets",
      "contact": "Contact"
    }
  },
  "index": {
    "banner": {
      "greeting": "Salut, je me présente",
      "firstName": "Alexandre",
      "lastName": "Beduc.",
      "information": "Développeur Python Junior."
    },
    "form": {
      "title": "Entrons en contact",
      "description": "Si vous avez des questions, une opportunité d'emploi ou un projet en tête, n'hésitez pas à me contacter. Je suis impatient de discuter de la manière dont nous pourrions collaborer.",
      "labelFirstName": "Prénom*",
      "labelLastName": "Nom*",
      "labelEmail": "E-mail*",
      "labelCompany": "Entreprise",
      "labelMessage": "Votre message*",
      "button": "Envoyer"
    }
  },
  "project": {
    "chessLogApp": {
      "card": {
        "title": "Chess Log Tournament",
        "skill": {
          "01": "Python",
          "02": "MVC",
          "03": "Curses"
        },
        "content": "Automatise l’organisation d’un tournoi d’échecs : saisie des résultats, appariements système suisse et classement en temps réel."
      },
      "detail": {
        "description": {
          "title": "Logiciel de tournoi",
          "content": {
            "01": "Calculer les scores pendant un tournoi d'échec doit être une tâche la plus simple possible pour utiliser sa matière grise pour ce qui compte vraiment, calculer le prochain coup. Fini les feuilles de score égarées, les appariements approximatifs et les erreurs d'additions. Désormais grâce à notre logiciel affiché dans le terminal, vous pourrez décharger l'arbitre de ces tâches répétitives.",
            "02": "Chess Log Tournament",
            "03": " est un gestionnaire de tournoi écrit 100% en Python, basé sur le ",
            "04": "design pattern MVC,",
            "05": " et une interface soignée grâce au ",
            "06": "module curses."
            }
          },
        "imageText": {
          "01": "",
          "02": "Exemple de fonctionnement lors d'un tournoi",
          "03": ""
        },
        "whatILearned": {
          "title": "Des choix fonctionnels",
          "content": {
            "01": "Malgré un cahier des charges techniques complet, certains points restaient ouverts à interprétation ; l'implémentation suit donc ces principes : ",
            "02": " > Chaque action (création de joueur, saisie de résultat, lancement d’un round) est immédiatement sauvegardée dans des fichiers JSON qui font office de base de données ; cela garantit une reprise instantanée après coupure et permet des modifications faciles directement dans les fichiers.",
            "03": " > L’algorithme d’appariement implémente la \"circle method\" du round-robin : pour n joueurs, il génère automatiquement n - 1 rounds où personne n’affronte deux fois le même adversaire. À chaque nouveau round, le logiciel extrait parmi les appariements disponibles celui qui fait s’opposer les joueurs aux meilleurs scores.",
            "04": " > L’interface repose entièrement sur le module curses (issu de la bibliothèque C homonyme). Fenêtres et navigation se pilotent uniquement au clavier, pour une expérience fluide et intuitive."
          }
        }
      }
    },
    "litrevu": {
      "card": {
        "title": "LITRevu Website",
        "skill": {
          "01": "Django",
          "02": "Jinja2",
          "03": "SQLite"
        },
        "content": "Site de partage et de demande de critiques de livres. Fil d’actualité personnalisé grâce à un système d’abonnements et de blocages."
      },
      "detail": {
        "description": {
          "title": "Site de critique de livres",
          "content": {
            "01": "Envie de savoir si ce roman de 900 pages vaut vraiment le détour ? Besoin de recommander votre dernière pépite littéraire à des passionnés ? LITRevu est fait pour vous : ouvrez un ticket, demandez une critique ou publiez la vôtre, le tout dans une interface épurée.",
            "02": "LITRevu",
            "03": " développé avec ",
            "04": "Django",
            "05": " et une base ",
            "06": "SQLite",
            "07": " propose une expérience minimaliste mais complète pour échanger autour de la lecture."
            }
          },
        "imageText": {
          "01": "",
          "02": "Site en cours d'utilisation",
          "03": "Système d'abonnement"
        },
        "whatILearned": {
          "title": "Premiers pas avec Django",
          "content": {
            "01": "Ce projet m'a permis de décourir le framework Django : l'architecture MVT, le routage, les modèles et leurs formulaires. J’ai mis en place un fil d’actualité dynamique, un système d’abonnement/blocage entre utilisateurs.",
            "02": "Côté interface, si celle-ci reste très basique, j’ai créé des widgets personnalisés, ajouté des interactions JavaScript légères et structuré les styles en SCSS pour un code plus maintenable."
          }
        }
      }
    },
    "softdesk": {
      "card": {
        "title": "SoftDesk API",
        "skill": {
          "01": "Django REST Framework",
          "02": "Postman",
          "03": "SQLite"
        },
        "content": "API REST pour le suivi de projets, cloisonnée par un système de permissions."
      },
      "detail": {
        "description": {
          "title": "API de gestion de projets",
          "content": {
            "01": "Cette API RESTful permet aux utilisateurs de créer et gérer des projets. Organisez votre travail avec vos contributeurs via un système de tickets et de commentaires. Travaillez efficacement en équipe, avec des rôles clairement définis.",
            "02": "SoftDesk API,",
            "03": " développée avec ",
            "04": "Django REST Framework",
            "05": " et une base ",
            "06": "SQLite,",
            "07": " intègre une authentification JWT, des permissions fines et des filtres sur chaque liste pour retrouver rapidement la ressource désirée."
          }
        },
        "imageText": {
          "01": "",
          "02": "Schéma des relations",
          "03": ""
        },
        "whatILearned": {
          "title": "Concevoir une API sécurisée",
          "content": {
            "01": "J’ai conçu ma première API complète : modélisation relationnelle, sérialiseurs imbriqués et routes HATEOAS grâce à drf-nested-routers. J’ai mis en place l’authentification JWT ainsi qu’un système de permissions sur mesure pour assurer la sécurité des projets.",
            "02": "Côté outillage, j’ai créé une collection Postman exhaustive et ajouté des filtres dynamiques."
          }
        }
      }
    }
  }
}